# research: brain hooks adapter templates

## overview

this document researches the templates and patterns needed to implement a brain hooks adapter for claude code in the rhachet-brains-anthropic package.

---

## sources

| # | source | description |
|---|--------|-------------|
| [1] | `github.com/ehmpathy/rhachet/src/_topublish/rhachet-brains-anthropic/` | template directory for brain hooks adapter |
| [2] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainHook.ts` | BrainHook domain object type |
| [3] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainHookEvent.ts` | BrainHookEvent type definition |
| [4] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainHooksAdapter.ts` | BrainHooksAdapter interface |
| [5] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainHooksAdapterDao.ts` | BrainHooksAdapterDao interface |
| [6] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainSpecifier.ts` | BrainSpecifier type |
| [7] | `github.com/ehmpathy/rhachet/src/domain.objects/BrainHookFilter.ts` | BrainHookFilter domain object |
| [8] | `github.com/ehmpathy/rhachet/src/domain.objects/RoleHookOnBrain.ts` | RoleHookOnBrain type |
| [9] | `github.com/ehmpathy/rhachet/src/domain.objects/RoleHooksOnBrain.ts` | RoleHooksOnBrain container type |

---

## key patterns from templates

### 1. template file structure [1]

the template organizes brain hooks adapter code as:

```
src/
├── hooks/
│   ├── config.dao.ts              # reads/writes .claude/settings.json
│   ├── config.dao.test.ts         # tests for config dao
│   ├── genBrainHooksAdapterForClaudeCode.ts    # main adapter factory
│   ├── genBrainHooksAdapterForClaudeCode.test.ts
│   ├── getBrainHooks.ts           # supplier contract entry point
│   ├── getBrainHooks.test.ts
│   ├── translateHook.ts           # bidirectional hook translation
│   └── translateHook.test.ts
└── index.ts                       # exports genBrainHooksAdapterForClaudeCode, getBrainHooks
```

### 2. BrainHooksAdapter interface [4]

from source [4], the adapter contract:

```ts
/**
 * .what = adapter contract that wraps DAO with slug identifier
 * .why = brain suppliers implement this interface to support hook sync
 *
 * .note = slug identifies the brain (e.g., "claudecode", "opencode")
 */
export interface BrainHooksAdapter {
  slug: string;
  dao: BrainHooksAdapterDao;
}
```

### 3. BrainHooksAdapterDao interface [5]

from source [5], the dao contract uses declastruct pattern:

```ts
/**
 * .what = DAO interface contract for brain hooks CRUD operations
 * .why = enables declastruct pattern with idempotent get/set/del semantics
 *
 * .note = uses method syntax for bivariance (see define.bivariance-for-generics)
 */
export interface BrainHooksAdapterDao {
  get: {
    one(input: {
      by: { unique: RefByUnique<typeof BrainHook> };
    }): Promise<BrainHook | null>;
    all(input?: {
      by?: PickOne<{ author: string; event: BrainHookEvent; command: string }>;
    }): Promise<BrainHook[]>;
  };
  set: {
    findsert(input: { hook: BrainHook }): Promise<BrainHook>;
    upsert(input: { hook: BrainHook }): Promise<BrainHook>;
  };
  del(input: { by: { unique: RefByUnique<typeof BrainHook> } }): Promise<void>;
}
```

### 4. BrainHook domain object [2]

from source [2], the hook structure:

```ts
/**
 * .what = brain hook with author namespace for ownership track
 * .why = enables declarative sync with namespace isolation
 *
 * .note = author format: "repo={registry.slug}/role={role.slug}"
 * .note = timeout format: ISO 8601 duration (e.g., "PT60S", "PT5M")
 */
export interface BrainHook {
  author: string;
  event: BrainHookEvent;
  command: string;
  timeout: IsoDuration;
  filter?: BrainHookFilter;
}

export class BrainHook extends DomainEntity<BrainHook> implements BrainHook {
  public static unique = ['author', 'event', 'command'] as const;
  public static updatable = ['filter', 'timeout'] as const;
}
```

### 5. BrainHookEvent types [3]

from source [3], the event map:

```ts
/**
 * .what = event types that trigger brain hooks
 * .why = defines the lifecycle moments where hooks can execute
 *
 * .note = maps to brain-specific events:
 *   - onBoot → SessionStart (claudecode), session.created (opencode)
 *   - onTool → PreToolUse/PostToolUse (claudecode), tool.execute.before/after (opencode)
 *   - onStop → Stop (claudecode), session.idle (opencode)
 */
export type BrainHookEvent = 'onBoot' | 'onTool' | 'onStop';
```

### 6. BrainHookFilter for tool filter [7]

from source [7]:

```ts
/**
 * .what = filter criteria for onTool hooks
 * .why = separates tool selection from execution time
 *
 * .note = what: tool pattern like "Bash", "Write|Edit", "*"
 * .note = when: defaults to "before" if not specified
 */
export interface BrainHookFilter {
  what: string;
  when?: 'before' | 'after';
}
```

### 7. event map pattern [1]

from the template's `translateHook.ts`:

```ts
/**
 * .what = maps rhachet BrainHookEvent to claude code hook event name
 * .why = claude code uses different event names than rhachet
 */
const EVENT_MAP: Record<BrainHookEvent, string> = {
  onBoot: 'SessionStart',
  onTool: 'PreToolUse',
  onStop: 'Stop',
};
```

### 8. claude code settings structure [1]

from the template's `config.dao.ts`:

```ts
/**
 * .what = claude code settings shape for hooks section
 * .why = typed representation of .claude/settings.json hooks structure
 */
export interface ClaudeCodeHookEntry {
  matcher: string;
  hooks: Array<{
    type: string;
    command: string;
    timeout?: number;
  }>;
}

export interface ClaudeCodeSettings {
  hooks?: {
    SessionStart?: ClaudeCodeHookEntry[];
    PreToolUse?: ClaudeCodeHookEntry[];
    PostToolUse?: ClaudeCodeHookEntry[];
    Stop?: ClaudeCodeHookEntry[];
  };
  [key: string]: unknown;
}
```

### 9. author tag pattern [1]

from `genBrainHooksAdapterForClaudeCode.ts`, author identification via matcher comment:

```ts
// tag entry with author for later identification
entry.matcher = `# author=${hook.author} ${entry.matcher}`;

// extract author from matcher comment pattern
const authorMatch = entry.matcher.match(/^#\s*author=([^\s]+)/);
const entryAuthor = authorMatch?.[1] ?? 'unknown';
```

### 10. getBrainHooks supplier contract [1]

from the template's `getBrainHooks.ts`:

```ts
/**
 * .what = returns brain hooks adapter for specified brain
 * .why = supplier contract for rhachet to discover adapters
 *
 * .note = currently only supports claude-code brain
 */
export const getBrainHooks = (input: {
  brain: BrainSpecifier;
  repoPath: string;
}): BrainHooksAdapter | null => {
  const { brain, repoPath } = input;

  // check if this supplier supports the requested brain
  if (brain === 'claude-code' || brain === 'anthropic/claude/code') {
    return genBrainHooksAdapterForClaudeCode({ repoPath });
  }

  // this supplier does not support the requested brain
  return null;
};
```

### 11. timeout conversion pattern [1]

from `translateHook.ts`, convert IsoDuration to milliseconds:

```ts
import { toMilliseconds } from 'iso-time';

// convert IsoDuration to milliseconds for claude code
const timeoutMs = toMilliseconds(hook.timeout);
```

and back:

```ts
// timeout to IsoDuration object
timeout: h.timeout ? { milliseconds: h.timeout } : { seconds: 30 },
```

### 12. package.json configuration [1]

from the template's `package.json`:

```json
{
  "name": "rhachet-brains-anthropic",
  "version": "0.0.1",
  "description": "rhachet brain supplier for anthropic (claude-code)",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "peerDependencies": {
    "rhachet": ">=1.20.0"
  },
  "dependencies": {
    "domain-objects": "^1.0.0",
    "type-fns": "^1.0.0"
  }
}
```

---

## how templates relate to the wish

### wish requirements map

| requirement | template solution |
|-------------|------------------|
| "Role.hooks.onBrain interface" | BrainHooksAdapter + BrainHooksAdapterDao interfaces from rhachet |
| "brain hook adapters for claude code" | genBrainHooksAdapterForClaudeCode factory |
| "supplier contract" | getBrainHooks entry point that matches brain specifier |
| "fulfill the full contract" | implement BrainHooksAdapterDao with get.one, get.all, set.findsert, set.upsert, del |
| "cover with tests" | bdd-style tests via given/when/then from test-fns |

### key implementation requirements

1. **settings persistence**: read/write `.claude/settings.json` via config.dao
2. **bidirectional translation**: convert rhachet BrainHook ↔ claude code hook format
3. **author namespace isolation**: embed author in matcher comment for ownership track
4. **idempotent operations**: findsert/upsert semantics per declastruct pattern
5. **filter support**: map BrainHookFilter.what to claude code matcher string
6. **timeout handle**: convert IsoDuration ↔ milliseconds

### types to import from rhachet

all these types are exported from `rhachet` package:

- `BrainHook`
- `BrainHookEvent`
- `BrainHookFilter`
- `BrainHooksAdapter`
- `BrainHooksAdapterDao`
- `BrainSpecifier`

---

## test coverage patterns

from the template tests, required coverage:

1. **config.dao.test.ts**: settings read/write operations
2. **translateHook.test.ts**: bidirectional translation accuracy
3. **genBrainHooksAdapterForClaudeCode.test.ts**: full dao operations
4. **getBrainHooks.test.ts**: brain specifier match

test patterns use:
- `given/when/then` from `test-fns`
- `useBeforeAll` for shared setup
- tmpdir for isolated test repos
- `[caseN]` and `[tN]` labels per bdd conventions

---

## dependencies

from template analysis:

| dependency | purpose |
|------------|---------|
| `rhachet` | peer dep for types (BrainHook, BrainHooksAdapter, etc) |
| `domain-objects` | DomainEntity/DomainLiteral base classes |
| `type-fns` | PickOne utility type |
| `iso-time` | IsoDuration parse and toMilliseconds conversion |
| `test-fns` | given/when/then test utilities |
