# blueprint: brain hooks adapter for claude code

## overview

this blueprint describes the implementation plan to port the brain hooks adapter from `github.com/ehmpathy/rhachet/src/_topublish/rhachet-brains-anthropic/` to this repo, fulfill the `BrainHooksAdapter` contract, and cover with thorough tests.

---

## file structure

follow current repo patterns + template structure:

```
src/
├── domain.operations/
│   └── hooks/
│       ├── config.dao.ts                              # read/write .claude/settings.json
│       ├── config.dao.integration.test.ts             # integration: file persistence
│       ├── translateHook.ts                           # BrainHook ↔ claude code format
│       ├── translateHook.test.ts                      # unit: translation accuracy
│       ├── genBrainHooksAdapterForClaudeCode.ts       # main adapter factory
│       ├── genBrainHooksAdapterForClaudeCode.test.ts  # unit: adapter factory shape
│       ├── genBrainHooksAdapterForClaudeCode.integration.test.ts  # integration: adapter contract
│       ├── getBrainHooks.ts                           # supplier contract entry point
│       └── getBrainHooks.test.ts                      # unit: brain specifier match
├── contract/
│   └── sdk/
│       └── index.ts                                   # add getBrainHooks export
└── index.ts                                           # re-export from contract/sdk
```

---

## implementation steps

### step 1: config.dao.ts

**location**: `src/domain.operations/hooks/config.dao.ts`

**purpose**: read/write `.claude/settings.json`

**key patterns**:

```ts
export interface ClaudeCodeHookEntry {
  matcher: string;
  hooks: Array<{
    type: string;
    command: string;
    timeout?: number;
  }>;
  author?: string;  // rhachet namespace, ignored by claude code
}

export interface ClaudeCodeSettings {
  hooks?: {
    SessionStart?: ClaudeCodeHookEntry[];
    PreToolUse?: ClaudeCodeHookEntry[];
    PostToolUse?: ClaudeCodeHookEntry[];
    Stop?: ClaudeCodeHookEntry[];
  };
  [key: string]: unknown;
}

export const readClaudeCodeSettings = async (input: {
  from: string;
}): Promise<ClaudeCodeSettings>

export const writeClaudeCodeSettings = async (input: {
  settings: ClaudeCodeSettings;
  to: string;
}): Promise<void>
```

**behaviors to test (integration)** - `config.dao.integration.test.ts`:

```
given '[case1] empty repo (no .claude directory)'
  when '[t0] readClaudeCodeSettings is called'
    then 'returns empty object {}'
  when '[t1] writeClaudeCodeSettings is called with hooks'
    then 'creates .claude directory'
    then 'creates settings.json file'
    then 'file contains valid json'

given '[case2] repo with .claude directory but no settings.json'
  when '[t0] readClaudeCodeSettings is called'
    then 'returns empty object {}'
  when '[t1] writeClaudeCodeSettings is called'
    then 'creates settings.json'

given '[case3] repo with prior settings.json (no hooks)'
  when '[t0] readClaudeCodeSettings is called'
    then 'returns parsed settings'
    then 'preserves non-hook settings (e.g., permissions)'
  when '[t1] writeClaudeCodeSettings is called with hooks'
    then 'file contains hooks section'
    then 'prior non-hook settings are preserved'

given '[case4] repo with prior settings.json (with hooks)'
  when '[t0] readClaudeCodeSettings is called'
    then 'returns settings with hooks'
    then 'hooks.SessionStart is array'
    then 'hooks.PreToolUse is array'
  when '[t1] writeClaudeCodeSettings overwrites hooks'
    then 'new hooks replace old hooks'
    then 'prior non-hook settings preserved'

given '[case5] json format validation'
  when '[t0] writeClaudeCodeSettings is called'
    then 'json is formatted with 2-space indentation'
    then 'file ends with newline'
    then 'json is valid (parseable)'

given '[case6] multiple hook events'
  when '[t0] write settings with SessionStart + PreToolUse + Stop hooks'
    then 'all event types are written'
  when '[t1] read settings back'
    then 'all event types are returned'
    then 'hook entries have correct structure'

given '[case7] hook entry with author attribute'
  when '[t0] write entry with author="repo=test/role=mechanic"'
    then 'author attribute is persisted'
  when '[t1] read settings back'
    then 'author attribute is present on entry'

given '[case8] empty hooks section'
  when '[t0] write settings with hooks: {}'
    then 'hooks key is present'
    then 'hooks value is empty object'
  when '[t1] read settings back'
    then 'hooks is empty object'
```

---

### step 2: translateHook.ts

**location**: `src/domain.operations/hooks/translateHook.ts`

**purpose**: bidirectional translation between rhachet `BrainHook` and claude code hook format

**key patterns**:

```ts
import type { BrainHook, BrainHookEvent } from 'rhachet';
import { toMilliseconds } from 'iso-time';

const EVENT_MAP: Record<BrainHookEvent, string> = {
  onBoot: 'SessionStart',
  onTool: 'PreToolUse',
  onStop: 'Stop',
};

export const translateHookToClaudeCode = (input: {
  hook: BrainHook;
}): { event: string; entry: ClaudeCodeHookEntry }

export const translateHookFromClaudeCode = (input: {
  event: string;
  entry: ClaudeCodeHookEntry;
}): BrainHook[]
```

**behaviors to test**:
- `translateHookToClaudeCode`:
  - onBoot → SessionStart
  - onTool → PreToolUse
  - onStop → Stop
  - timeout: IsoDuration → milliseconds
  - filter.what → matcher (defaults to `*`)
  - hook.author → entry.author
- `translateHookFromClaudeCode`:
  - SessionStart → onBoot
  - PreToolUse → onTool
  - Stop → onStop
  - timeout: milliseconds → IsoDuration object
  - no timeout → default { seconds: 30 }
  - matcher → filter.what (unless `*`)
  - entry.author → hook.author (defaults to `'unknown'`)
  - unknown event → returns empty array
  - entry with multiple hooks → returns multiple BrainHook

---

### step 3: genBrainHooksAdapterForClaudeCode.ts

**location**: `src/domain.operations/hooks/genBrainHooksAdapterForClaudeCode.ts`

**purpose**: factory that creates `BrainHooksAdapter` for a specific repo path

**key patterns**:

```ts
import type { BrainHook, BrainHooksAdapter, BrainHookEvent } from 'rhachet';

export const genBrainHooksAdapterForClaudeCode = (input: {
  repoPath: string;
}): BrainHooksAdapter
```

**adapter contract** (BrainHooksAdapterDao):

| method | purpose |
|--------|---------|
| `get.one({ by: { unique } })` | find single hook by author+event+command |
| `get.all(filter?)` | list all hooks, optionally filtered by author, event, or command |
| `set.findsert({ hook })` | insert if absent, return found if present |
| `set.upsert({ hook })` | insert or update hook |
| `del({ by: { unique } })` | remove hook by unique key |

**author attribute pattern**:
- on upsert: set `entry.author = hook.author`
- on read: read `entry.author` directly (claude code ignores unknown attributes)

**behaviors to test (unit)**:
- returns adapter with slug `'claude-code'`
- dao.get, dao.set, dao.del methods are defined

**behaviors to test (integration)** - `genBrainHooksAdapterForClaudeCode.integration.test.ts`:

```
given '[case1] empty repo (no .claude/settings.json)'
  when '[t0] dao.get.all is called'
    then 'returns empty array'
  when '[t1] dao.set.upsert is called'
    then 'creates .claude/settings.json'
    then 'hook is found in dao.get.all'

given '[case2] repo with hooks'
  when '[t0] dao.get.all is called'
    then 'returns all hooks'
  when '[t1] dao.get.all with { by: { author } } filter'
    then 'returns only hooks with that author'
  when '[t2] dao.get.all with { by: { event } } filter'
    then 'returns only hooks with that event'
  when '[t3] dao.get.all with { by: { command } } filter'
    then 'returns only hooks with that command'

given '[case3] dao.get.one'
  when '[t0] hook present'
    then 'returns the hook'
  when '[t1] hook absent'
    then 'returns null'

given '[case4] dao.set.upsert'
  when '[t0] hook does not exist'
    then 'creates the hook'
  when '[t1] hook exists with same unique key'
    then 'updates timeout/filter'
    then 'does not create duplicate'

given '[case5] dao.set.findsert'
  when '[t0] hook does not exist'
    then 'creates the hook'
  when '[t1] same hook findserted twice'
    then 'only one hook exists'
    then 'returns found hook'

given '[case6] dao.del'
  when '[t0] hook present'
    then 'removes the hook'
    then 'dao.get.one returns null after'
  when '[t1] hook absent'
    then 'no error thrown'

given '[case7] hook with filter'
  when '[t0] dao.set.upsert hook with filter.what="Write"'
    then 'settings.json contains matcher "Write"'
  when '[t1] dao.get.all'
    then 'returned hook has filter.what="Write"'

given '[case8] multiple authors'
  when '[t0] upsert hooks from author A and author B'
    then 'dao.get.all returns both'
  when '[t1] dao.get.all with { by: { author: "A" } }'
    then 'returns only author A hooks'
  when '[t2] dao.del author A hook'
    then 'author B hooks remain'
```

---

### step 4: getBrainHooks.ts

**location**: `src/domain.operations/hooks/getBrainHooks.ts`

**purpose**: supplier contract entry point for rhachet to discover adapters

**key patterns**:

```ts
import type { BrainHooksAdapter, BrainSpecifier } from 'rhachet';

export const getBrainHooks = (input: {
  brain: BrainSpecifier;
  repoPath: string;
}): BrainHooksAdapter | null
```

**supported specifiers**:
- `'claude'` → returns adapter (short alias)
- `'claude-code'` → returns adapter
- `'anthropic/claude/code'` → returns adapter
- any other → returns `null`

**behaviors to test**:
- brain `'claude'` → returns adapter with slug `'claude-code'`
- brain `'claude-code'` → returns adapter with slug `'claude-code'`
- brain `'anthropic/claude/code'` → returns adapter
- brain `'opencode'` → returns null
- brain unknown string → returns null

---

### step 5: sdk export

**location**: `src/contract/sdk/index.ts`

**add export**:

```ts
// brain hooks adapter
export { getBrainHooks } from '../../domain.operations/hooks/getBrainHooks';
export { genBrainHooksAdapterForClaudeCode } from '../../domain.operations/hooks/genBrainHooksAdapterForClaudeCode';
```

---

## test coverage matrix

### unit tests

| file | coverage |
|------|----------|
| `translateHook.test.ts` | bidirectional translation, all events, timeout conversion, author |
| `genBrainHooksAdapterForClaudeCode.test.ts` | adapter factory returns correct shape, dao methods defined |
| `getBrainHooks.test.ts` | brain specifier match/mismatch for all aliases |

### integration tests

| file | coverage |
|------|----------|
| `config.dao.integration.test.ts` | file persistence: read/write .claude/settings.json |
| `genBrainHooksAdapterForClaudeCode.integration.test.ts` | adapter contract: dao.get.one, dao.get.all, dao.set.upsert, dao.set.findsert, dao.del |

**integration test pattern**:
```ts
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';
import { given, then, useBeforeAll, when } from 'test-fns';

given('[case1] empty repo (no .claude/settings.json)', () => {
  const repo = useBeforeAll(async () => {
    const dir = path.join(os.tmpdir(), `claude-test-${Date.now()}`);
    await fs.mkdir(dir, { recursive: true });
    return { path: dir };
  });

  when('[t0] get.all is called', () => {
    then('returns empty array', async () => { ... });
  });

  when('[t1] set.upsert is called', () => {
    then('creates settings file', async () => { ... });
    then('hook is found in get.all', async () => { ... });
  });
});
```

---

## dependencies

### required additions to package.json

```json
{
  "dependencies": {
    "iso-time": "^1.0.0"
  }
}
```

**note**: `rhachet` is already a peer dependency (provides `BrainHook`, `BrainHooksAdapter`, etc.)

---

## implementation order

1. `config.dao.ts` + `config.dao.test.ts`
2. `translateHook.ts` + `translateHook.test.ts`
3. `genBrainHooksAdapterForClaudeCode.ts` + unit test
4. `genBrainHooksAdapterForClaudeCode.integration.test.ts`
5. `getBrainHooks.ts` + `getBrainHooks.test.ts`
6. update `src/contract/sdk/index.ts` with exports
7. verify build + all tests pass

---

## acceptance criteria

| criteria | verification |
|----------|--------------|
| `getBrainHooks` returns adapter for `'claude-code'` | unit test |
| adapter fulfills `BrainHooksAdapterDao` contract | integration test |
| hooks persist to `.claude/settings.json` | integration test |
| author namespace isolation via entry.author attribute | integration test |
| bidirectional translation preserves data | unit test |
| idempotent operations (findsert, upsert) | integration test |
| types import from `rhachet` package | build pass |

---

## risk notes

1. **iso-time dependency**: template uses `toMilliseconds` from `iso-time`. verify this package is compatible with current rhachet's IsoDuration format.

2. **settings.json format**: claude code settings format may evolve. the hook entry structure is typed but uses `[key: string]: unknown` escape hatch for forward compat.

3. **author attribute removal**: if user manually edits settings.json and removes author attribute, hooks may become orphaned. this is acceptable tradeoff for simplicity.
